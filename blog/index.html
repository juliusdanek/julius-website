<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Julius' Blog &middot; Lifes's an adventure
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/public/css/poole.css">
  <link rel="stylesheet" href="/blog/public/css/syntax.css">
  <link rel="stylesheet" href="/blog/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/public/favicon_large.png">
  <link rel="shortcut icon" href="/blog/public/favicon_32x32.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <img class="sidebar-img" src="http://juliusdanek.de/blog//assets/images/julius_square_edited.jpg">
    <p>A blog by Julius Danek. For more details check out the about me, archives and my website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/blog/">Posts</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/blog/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/blog/archives/">Archives</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
    <a class="sidebar-nav-item" href="http://juliusdanek.de" target="_blank">Website</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2015. All rights reserved. Built with <a href="https://github.com/poole/lanyon" target="_blank">Lanyon</a> by <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/blog/" title="Home">Julius' Blog</a>
            <small>Lifes's an adventure</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog//coding/2015/07/14/persistent-pins-tutorial/">
        Swift Tutorial -  Persistent Annotations in MapKit with Core Data
      </a>
    </h1>

    <span class="post-date">14 Jul 2015</span>

    <h2 id="persistent-annotations-in-mapkit">Persistent Annotations in MapKit</h2>

<p>Hi everyone, in this tutorial we will use CoreData to persist pin annotations on a map using Apple’s MapKit in six simple steps. Basic familiarity with CoreData and iOS development is assumed. This tutorial was done for an iPhone 6 and iOS 8.</p>

<p>In Persistent-Pins we will drop pins on a mapView using the UILongPressGestureRecognizer. Dropped Pins will be immediately saved to a CoreData database. Pins can be deleted with taps. On restart, all placed Pins will have persisted on the map. My Github contains the finished project with comments, the steps can be found as commits.</p>

<p>Github link to finished project: <a href="https://github.com/juliusdanek/Persistent-Pins-Tutorial">https://github.com/juliusdanek/Persistent-Pins-Tutorial</a></p>

<h3 id="step-one---setting-up-our-model-and-coredata">Step one - Setting up our model and CoreData</h3>

<p>Let’s start by initializing the project. Create a new project in Xcode, starting from a single view application. Choose Swift as language and enable CoreData by ticking the “Use Core Data” box.</p>

<p><img src="/blog/assets/images/start-model.png" alt="Start model picture" /></p>

<p>Your project is now ready. Checkout how CoreData is initialized in the AppDelegate.</p>

<p>Let’s navigate to our model, “Persistent-Pins”. This is where we are going to define our entity. Let’s add one entity and name it “Pin”. Add two attributes to your new “Pin” entity. “latitude” and “longitude” are both going to be attributes and will be of type “Double”. We will store our Pin’s latitude and longitude in these properties. 
###Step two - Setting up our managed object</p>

<p>Next, we are going to set up our managed object or entity. Navigate to your model “Persistent Pins” and go on “Editor”. Select “create NSManaged Object subclass…”. Choose Persistent Pins, then Pin, then change the language to Swift and save the file to your project folder (select the right group - persistent pins - in the group dropdown).</p>

<p><img src="/blog/assets/images/pin-attribute.png" alt="pin attributes picture" /></p>

<p>At the top of the file, create another import statement for MapKit. We will need CoreData to save our Pins to our model and we will need MapKit to make the Pins that we save a subclass of MKAnnotation - this will allow us to populate our map with Pins directly from CoreData.</p>

<p>Place an @objc(Pin) under your import statements to ensure compatibility with objective-c - see <a href="http://stackoverflow.com/questions/24015185/generating-swift-models-from-core-data-entities">http://stackoverflow.com/questions/24015185/generating-swift-models-from-core-data-entities</a> for more details.</p>

<p>You can see that “Pin” is already a subclass of NSManagedObject. Let’s make it a subclass of MKAnnotation as well. We will now receive an error message that our Pin does not conform to the MKAnnotation protocol. Let’s change that.</p>

<p>At the bottom of the class declaration, add the variable “coordinate” of class CLLocationCoordinate2D like so:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nl">coordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
	        <span class="k">return</span> <span class="n">CLLocationCoordinate2D</span><span class="p">(</span><span class="nl">latitude</span><span class="p">:</span> <span class="n">latitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude</span><span class="p">:</span> <span class="n">longitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">)</span>
	    <span class="p">}</span></code></pre></div>

<p>By now you will have noticed that latitude and longitude are declared as NSNumber. The problem is that CoreData will not recognize the Swift type <strong>Double</strong>. You will simply have to convert between Doubles and NSNumbers.</p>

<p>Let’s provide our custom init method in the next step. Add this code below where you define your @NSManaged vars.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kr">override</span> <span class="nf">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="bp">NSEntityDescription</span><span class="p">,</span> <span class="n">insertIntoManagedObjectContext</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">init</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="n">entity</span> <span class="o">=</span> <span class="bp">NSEntityDescription</span><span class="p">.</span><span class="n">entityForName</span><span class="p">(</span><span class="s">&quot;Pin&quot;</span><span class="p">,</span> <span class="nl">inManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span><span class="o">!</span>
        
        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
        
        <span class="n">latitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLatitude</span><span class="p">)</span>
        
        <span class="n">longitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLongitude</span><span class="p">)</span>
    <span class="p">}</span></code></pre></div>

<p>Our custom init method allows us to find our entity and initialize a Pin CoreData entry with our custom latitude and longitude values. This initializer will also automatically generate your coordinate.</p>

<p><strong>Finally, navigate to your model and change the class in your Pin entity to “Pin”</strong></p>

<p><img src="/blog/assets/images/pin-class.png" alt="pin class picture" /></p>

<p>Great, we are finished creating our custom object and are done with step one. This should be the finished code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">Foundation</span>
	<span class="k">import</span> <span class="n">CoreData</span>
	<span class="k">import</span> <span class="n">MapKit</span>

	<span class="k">class</span> <span class="nl">Pin</span><span class="p">:</span> <span class="bp">NSManagedObject</span><span class="p">,</span> <span class="bp">MKAnnotation</span> <span class="p">{</span>

	    <span class="p">@</span><span class="n">NSManaged</span> <span class="k">var</span> <span class="nl">latitude</span><span class="p">:</span> <span class="bp">NSNumber</span>
	    <span class="p">@</span><span class="n">NSManaged</span> <span class="k">var</span> <span class="nl">longitude</span><span class="p">:</span> <span class="bp">NSNumber</span>
	    
	    <span class="kr">override</span> <span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="bp">NSEntityDescription</span><span class="p">,</span> <span class="n">insertIntoManagedObjectContext</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
	        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
	    <span class="p">}</span>
	    
	    <span class="k">init</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">let</span> <span class="n">entity</span> <span class="o">=</span> <span class="bp">NSEntityDescription</span><span class="p">.</span><span class="n">entityForName</span><span class="p">(</span><span class="s">&quot;Pin&quot;</span><span class="p">,</span> <span class="nl">inManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span><span class="o">!</span>
	        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
	        <span class="n">latitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLatitude</span><span class="p">)</span>
	        <span class="n">longitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLongitude</span><span class="p">)</span>
	    <span class="p">}</span>
	    
	    <span class="k">var</span> <span class="nl">coordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
	        <span class="k">return</span> <span class="n">CLLocationCoordinate2D</span><span class="p">(</span><span class="nl">latitude</span><span class="p">:</span> <span class="n">latitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude</span><span class="p">:</span> <span class="n">longitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">)</span>
	    <span class="p">}</span>

	<span class="p">}</span></code></pre></div>

<h3 id="step-three----setting-up-our-ui-and-our-viewcontroller">Step three – setting up our UI and our ViewController</h3>

<p>Navigate to storyboard and drag a MapKit View onto your viewcontroller. Set the constraints so the MapView fills out the entire controller. Also, do not forget to enable MapKit in your projects capabilities. Go to persistent Pins and enable “Maps” under capabilities.</p>

<p><img src="/blog/assets/images/turnon-mapkit.png" alt="mapkit picture" /></p>

<p>Let’s create an outlet for our mapView in our ViewController file. ctrl + drag your mapView into your ViewController using the assistant editor and add an outlet named “mapView”. Do not forget to import MapKit into your ViewController and set your ViewController as MKMapViewDelegate.</p>

<p>In our viewDidLoad method, let’s add a long pressure gesture recognizer that will allow us to drop pins.</p>

<p>Your ViewController should look like this now:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">UIKit</span>
	<span class="k">import</span> <span class="n">MapKit</span>

	<span class="k">class</span> <span class="nl">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">MKMapViewDelegate</span> <span class="p">{</span>

	    <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span>
	    
	    <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
	        <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
	        
	        <span class="k">var</span> <span class="n">longPress</span> <span class="o">=</span> <span class="bp">UILongPressGestureRecognizer</span><span class="p">(</span><span class="nl">target</span><span class="p">:</span> <span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;dropPin:&quot;</span><span class="p">)</span>
	        <span class="n">longPress</span><span class="p">.</span><span class="n">minimumPressDuration</span> <span class="o">=</span> <span class="mf">0.5</span>
	        <span class="n">mapView</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">longPress</span><span class="p">)</span>
	        
	        <span class="n">mapView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
	        
	    <span class="p">}</span>
	<span class="p">}</span></code></pre></div>

<p>As you can see, the UILongPressGestureRecognizer us linked to a method called dropPin. We will implement that method next.</p>

<h3 id="step-four---the-droppin-method">Step four - the dropPin method</h3>

<p>Let’s define our dropPin method. We will have to do three things:</p>

<ol>
  <li>Extract the coordinates from the point where the user touched</li>
  <li>Add an annotation when the UIGestureRecognizerState fires</li>
  <li>Save that annotation to CoreData</li>
</ol>

<p>Let’s start by defining the function and extracting location data:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
	        
	        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
	        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
	    <span class="p">}</span></code></pre></div>

<p>Now, this method does not really do much yet. Let’s add a pin!</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">UIGestureRecognizerState</span><span class="p">.</span><span class="n">Began</span> <span class="o">==</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="bp">MKPointAnnotation</span><span class="p">()</span>
            <span class="n">pin</span><span class="p">.</span><span class="n">coordinate</span> <span class="o">=</span> <span class="n">touchMapCoordinate</span>
            <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>           
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>

<p>Now we can see pins dropping where we touched. This implementation is fairly straightforward. Our pins are not persistent yet though! Let’s change our dropPin function with this code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">UIGestureRecognizerState</span><span class="p">.</span><span class="n">Began</span> <span class="o">==</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">appDelegate</span> <span class="o">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">delegate</span> <span class="kt">as</span><span class="o">!</span> <span class="n">AppDelegate</span>
            
            <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">longitude</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="o">!</span><span class="p">)</span>
            <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
            <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>

<p>We will instantiate the appDelegate so we can use its methods. Then we proceed to instantiate a pin as our Pin class. We will initialize it with the coordinates from our touchMapCoordinate and use the appDelegate context as our context. Then we add the pin to our map view and we save our context - we could do this at another point too but it seems smart to do it here. We just successfully added a Pin to our CoreData model!</p>

<h3 id="step-five---fetching-our-pins-and-adding-them-to-our-map-when-starting-our-app">Step five - fetching our Pins and adding them to our map when starting our app</h3>

<p>Alright, let’s make sure that the pins that we insert into CoreData also get fetched when we need them, i.e. when the mapView loads. Let’s first change some of the logic that we implemented before. Import CoreData to our ViewController. Let’s also declare two implicitly unwrapped variables in ViewController:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nl">appDelegate</span><span class="p">:</span> <span class="n">AppDelegate</span><span class="o">!</span>
    <span class="k">var</span> <span class="nl">sharedContext</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">!</span></code></pre></div>

<p>Next, in our viewDidLoad method, at the very top, initialize the two new variables as so:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">appDelegate</span> <span class="o">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">delegate</span> <span class="kt">as</span><span class="o">!</span> <span class="n">AppDelegate</span>
        <span class="n">sharedContext</span> <span class="o">=</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span></code></pre></div>

<p>this allows us to access our NSManagedObjectContext and our saveContext() method throughout the ViewController. 
Do not forget to adjust the dropPin method accordingly! Delete the declaration of appDelegate that we had before and use the sharedContext variable in our init method.</p>

<p>Alright, let’s create a method for a fetchrequest! Simply use this code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="n">fetchAllPins</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nl">error</span><span class="p">:</span> <span class="n">NSErrorPointer</span> <span class="o">=</span> <span class="nb">nil</span>
        <span class="k">let</span> <span class="n">fetchRequest</span> <span class="o">=</span> <span class="bp">NSFetchRequest</span><span class="p">(</span><span class="nl">entityName</span><span class="p">:</span> <span class="s">&quot;Pin&quot;</span><span class="p">)</span>
        <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="n">sharedContext</span><span class="p">.</span><span class="n">executeFetchRequest</span><span class="p">(</span><span class="n">fetchRequest</span><span class="p">,</span> <span class="nl">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Error in fectchAllActors(): \(error)&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span> <span class="kt">as</span><span class="o">!</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span>
    <span class="p">}</span></code></pre></div>

<p>We create a fetchrequest, then execute it. In case there are any errors, we print the error to the console. The results are then returned as an array of pins. Now that we have a method can allows us to access our Pins as an array, let’s put them on the map! At the bottom of our viewDidLoad method, add the following code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotations</span><span class="p">(</span><span class="n">fetchAllPins</span><span class="p">())</span></code></pre></div>

<p>Great, now we are able to see the pins that we add. Let’s try it out.</p>

<h3 id="step-six---deleting-pins">Step six - deleting pins</h3>

<p>This step is remarkably easy. We will implement one of our delegate methods - didSelectAnnotation. The wonderful thing is that all mapView.annotations are saved as an array - an array of Pins! That means the selected annotation can always be casted as a Pin and deleted from the managed context. The method should look like this:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">mapView</span><span class="p">(</span><span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span><span class="p">,</span> <span class="n">didSelectAnnotationView</span> <span class="nl">view</span><span class="p">:</span> <span class="bp">MKAnnotationView</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">annotation</span> <span class="kt">as</span><span class="o">!</span> <span class="n">Pin</span>
        <span class="n">sharedContext</span><span class="p">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">mapView</span><span class="p">.</span><span class="n">removeAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
    <span class="p">}</span></code></pre></div>

<p>That was our last method! Our viewController should now look like this:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">CoreData</span>
<span class="k">import</span> <span class="n">UIKit</span>
<span class="k">import</span> <span class="n">MapKit</span>

<span class="k">class</span> <span class="nl">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">MKMapViewDelegate</span> <span class="p">{</span>

    <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span>
    
    <span class="k">var</span> <span class="nl">appDelegate</span><span class="p">:</span> <span class="n">AppDelegate</span><span class="o">!</span>
    <span class="k">var</span> <span class="nl">sharedContext</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">!</span>
    
    <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
        
        <span class="n">appDelegate</span> <span class="o">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">delegate</span> <span class="kt">as</span><span class="o">!</span> <span class="n">AppDelegate</span>
        
        <span class="n">sharedContext</span> <span class="o">=</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span>
        
        <span class="k">var</span> <span class="n">longPress</span> <span class="o">=</span> <span class="bp">UILongPressGestureRecognizer</span><span class="p">(</span><span class="nl">target</span><span class="p">:</span> <span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;dropPin:&quot;</span><span class="p">)</span>
        <span class="n">longPress</span><span class="p">.</span><span class="n">minimumPressDuration</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">mapView</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">longPress</span><span class="p">)</span>
        
        <span class="n">mapView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
        
        <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotations</span><span class="p">(</span><span class="n">fetchAllPins</span><span class="p">())</span>
    <span class="p">}</span>
    
    <span class="k">func</span> <span class="n">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">UIGestureRecognizerState</span><span class="p">.</span><span class="n">Began</span> <span class="o">==</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">longitude</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="o">!</span><span class="p">)</span>
            <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
            <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">func</span> <span class="n">mapView</span><span class="p">(</span><span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span><span class="p">,</span> <span class="n">didSelectAnnotationView</span> <span class="nl">view</span><span class="p">:</span> <span class="bp">MKAnnotationView</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">annotation</span> <span class="kt">as</span><span class="o">!</span> <span class="n">Pin</span>
        <span class="n">sharedContext</span><span class="p">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">mapView</span><span class="p">.</span><span class="n">removeAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
    <span class="p">}</span>
    
    
    <span class="k">func</span> <span class="n">fetchAllPins</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">error</span><span class="p">:</span> <span class="n">NSErrorPointer</span> <span class="o">=</span> <span class="nb">nil</span>
        <span class="k">let</span> <span class="n">fetchRequest</span> <span class="o">=</span> <span class="bp">NSFetchRequest</span><span class="p">(</span><span class="nl">entityName</span><span class="p">:</span> <span class="s">&quot;Pin&quot;</span><span class="p">)</span>
        <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="n">sharedContext</span><span class="p">.</span><span class="n">executeFetchRequest</span><span class="p">(</span><span class="n">fetchRequest</span><span class="p">,</span> <span class="nl">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Error in fectchAllActors(): \(error)&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span> <span class="kt">as</span><span class="o">!</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Tada! We are finished. Additional modification could include: Adding data like photos to a Pin, and defining a relationship between a Photo and the Pin object, using NSFetchResultsController to get results and update UI, modifying appearance of the Pins, displaying user location on map, etc.</p>

<p>I hope you enjoyed this tutorial!</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog//coding/2015/06/23/building-my-first-app%202/">
        Building my first iPhone apps
      </a>
    </h1>

    <span class="post-date">23 Jun 2015</span>

    <p>Over the past two weeks I have been following the udacity.com <a href="https://www.udacity.com/course/ios-developer-nanodegree--nd003">nanodegree for the Swift programming language</a>. What started off fairly slow with an introductory course to Swift and a first project, building an app that modified your voice when recording, continued with an extremely steep learning curve for the next project - a meme creator application.</p>

<p>In this app, the user would be able to take choose an image or take one with his/her camera and amend “meme-style” text to it. Then the user would be able to save or share the created memes and look at all the created memes in a table. What sounds very easy was actually quite challenging as it involved several important concepts that needed to be applied in order for the application to function:</p>

<ul>
  <li>Understanding the use of UIKit</li>
  <li>Using NSNotifiction Center</li>
  <li>Resizing images</li>
  <li>Accessing the camera roll and the photo library</li>
  <li>Using navigation controller</li>
  <li>Using the tab controller</li>
  <li>Pushing viewcontrollers modally and through different methods</li>
  <li>Setting up table and collection views</li>
  <li>NSDate</li>
</ul>

<p>I started out by setting up a tabbed application in Xcode. The picture shows how my storyboard is set up. For those of you that do not know, the storyboard connects all the visual element of an iOS application. You connect those visual elements to the code behind the app. The code controls the visual elements as well as the data behind an application. This interaction is called the MVC - model view controller. The model is the data, the view are the visual elements and the controller connects the two as well controlling the visual output depending on the data. For more info check out: <a href="http://blog.codinghorror.com/understanding-model-view-controller/">http://blog.codinghorror.com/understanding-model-view-controller/</a>.</p>

<p>Check out the storyboard for my application. The tab view controller is first. When pressing the button on the top right you navigate to the meme editor. From there, an interaction with the “share” button will bring up the activity controller. Any interaction with that controller will add the meme to the data model and will get displayed in the table view that was also the starting point in the app. When you select a meme in the table view (or the collection view which can be selected in the beginning of the app) you get shown a detail view that allows to edit the meme or delete it.</p>

<p><img src="/blog/assets/images/meme-storyboard.png" alt="Meme-Me app picture" /></p>

<p>This is the starting point of the app. On the top right you are able to open the meme editor and start editing memes. The view is split into a table view and a collection view, accessible through the tab bar on the bottom. Since the table and collection are not populated with data yet (the user hasn’t created any memes), they are both hidden and a label is displayed instead that tells the user to add a meme first. As you can see, the editing button on the top left is disabled as well.</p>

<p><img src="/blog/assets/images/meme-empty-table.jpg" alt="Meme-me table view" /></p>

<p>When the “add” button is touched up, the meme-editor pushes up modally (meaning that it is its own contained view, coming up from the bottom, as opposed to navigating deeper into the application to the right, like for example in the settings app on your iPhone). Here you are able to select an image from your camera roll or take one yourself. The image then gets fit into an imageview surrounded by two textfields. These textfields have been modified with custom properties. When you edit the bottom text field, the entire bottom view pushes up. This piece of code was actually quite some work as the viewcontroller has to subscribe to notifications when the keyboard would shift up or down. Once these notifications “arrive”, the screen can be shifted up by the height of the keyboard. After subscribing to notifications, you need to unsubscribe when exiting the view and you also need to implement a function to shift the view back down when the keyboard hides. Code snippet below:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="c1">//subscribing to notifications -&gt; This function gets called before the view appears</span>
    <span class="k">func</span> <span class="nf">subscribeToKeyboardNotifications</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">NSNotificationCenter</span><span class="p">.</span><span class="n">defaultCenter</span><span class="p">().</span><span class="n">addObserver</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nl">selector</span><span class="p">:</span> <span class="s">&quot;keyboardWillShow:&quot;</span>    <span class="p">,</span> <span class="nl">name</span><span class="p">:</span> <span class="n">UIKeyboardWillShowNotification</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
        <span class="bp">NSNotificationCenter</span><span class="p">.</span><span class="n">defaultCenter</span><span class="p">().</span><span class="n">addObserver</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nl">selector</span><span class="p">:</span> <span class="s">&quot;keyboardWillDisappear:&quot;</span><span class="p">,</span> <span class="nl">name</span><span class="p">:</span> <span class="n">UIKeyboardWillHideNotification</span><span class="p">,</span> <span class="nl">object</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">//finding out keyboard height in pixels</span>
    <span class="k">func</span> <span class="nf">getKeyboardHeight</span><span class="p">(</span><span class="nl">notification</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CGFloat</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">userInfo</span> <span class="o">=</span> <span class="n">notification</span><span class="p">.</span><span class="n">userInfo</span>
        <span class="k">let</span> <span class="n">keyboardSize</span> <span class="o">=</span> <span class="n">userInfo</span><span class="o">!</span><span class="p">[</span><span class="n">UIKeyboardFrameEndUserInfoKey</span><span class="p">]</span> <span class="kt">as</span><span class="o">!</span> <span class="bp">NSValue</span> <span class="c1">// of CGRect</span>
        <span class="k">return</span> <span class="n">keyboardSize</span><span class="p">.</span><span class="n">CGRectValue</span><span class="p">().</span><span class="n">height</span>
    <span class="p">}</span>
    
    <span class="c1">//what to do when the keyboard shifts up, conditional on the bottom text field being edited. Subtract the keyboard height from the frame origin, so it shifts up</span>
    <span class="k">func</span> <span class="n">keyboardWillShow</span><span class="p">(</span><span class="nl">notification</span><span class="p">:</span> <span class="bp">NSNotification</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;showing Keyboard&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bottomField</span><span class="p">.</span><span class="n">isFirstResponder</span><span class="p">()</span> <span class="p">{</span>
            <span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span>  <span class="o">-</span><span class="n">getKeyboardHeight</span><span class="p">(</span><span class="n">notification</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>

<p><img src="/blog/assets/images/meme-editor.jpg" alt="Meme Editor" /></p>

<p>After the meme is ready, the user can take touch up the share button on the top left, which brings up an activity controller. The activity controller receives a snapshot of the created image and allows the user to share or save it. Any action except cancel will exit the meme-editor and add the image to the saved memes. Saved memes actually is an array in the app delegate, storing all the memes (apparently this is bad practice but I will learn about different ways of storing data soon). For this purpose I created a custom class Meme that stores the memes original images, the bottom and top text, the memedImage and the date and time created.</p>

<p><img src="/blog/assets/images/meme-activity.jpg" alt="Meme Activity Controller" /></p>

<p>After choosing an activity, the meme-editor will get exited and we can see the table view populated with the meme that we just created. The edit button allows us to delete the meme. The date created, the top text and the memedImage are displayed in a table cell. Every time the view loads, the table gets updated and re-populated. When touch up on the meme, a detail view pulls up that allows you to see the meme in full detail as well as deleting or editing it. Editing will pull up the meme editor and pass the information stored in the meme struct (topText, bottomText, original image) to the editor, allowing you to start off with the original meme.</p>

<p><img src="/blog/assets/images/meme-table-full.jpg" alt="Meme Table Populated" title="Populated Table" /></p>

<p>Concluding, I am very satisfied with my progress. The app looks pretty sleek. I still have some issues understanding the whole navigation controller concept and with some of the layout stuff but overall I have a pretty good idea how the MVC concept works and how data gets passed around through the app. I am excited about my next projects.</p>

<p><img src="/blog/assets/images/meme-detail.jpg" alt="Meme Detail Delete" title="Detail View" /></p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
