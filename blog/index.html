<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Julius' Blog &middot; Lifes's an adventure
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/blog/public/css/poole.css">
  <link rel="stylesheet" href="/blog/public/css/syntax.css">
  <link rel="stylesheet" href="/blog/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/blog/public/favicon_large.png">
  <link rel="shortcut icon" href="/blog/public/favicon_32x32.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-65284345-1', 'auto');
  ga('send', 'pageview');

</script>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <img class="sidebar-img" src="http://juliusdanek.de/blog//assets/images/julius_square_edited.jpg">
    <p>A blog by Julius Danek. For more details check out the about me, archives and my website</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/blog/">Posts</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/blog/about/">About</a>
        
      
    
      
        
          <a class="sidebar-nav-item" href="/blog/archives/">Archives</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
    <a class="sidebar-nav-item" href="http://juliusdanek.de" target="_blank">Website</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2015. All rights reserved. Built with <a href="https://github.com/poole/lanyon" target="_blank">Lanyon</a> by <a href="https://twitter.com/mdo" target="_blank">@mdo</a>.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/blog/" title="Home">Julius' Blog</a>
            <small>Lifes's an adventure</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog//technology/2015/09/15/FinTech-under-banked-populations/">
        Opportunities to provide financial services to low-income populations in developed countries through technology
      </a>
    </h1>

    <span class="post-date">15 Sep 2015</span>

    <h2 id="the-economist-article">The economist article</h2>

<p>In the September 7 version of the Economist, the magazine published a very interesting article about how low-income populations (which I will coin LIP for lack of a better word - “the poor” does not seem appropriate) in the United States (and probably other industrial nation, even though I yet have to research on it), have much worse access to financial services than higher-income populations do (you can find the article <a href="http://www.economist.com/news/united-states/21663262-why-low-income-americans-often-have-pay-more-its-expensive-be-poor">here</a>.</p>

<p>Why is this the case? It is mostly the prohibitive cost. One outrageous example is the $40 per payroll check charged by 26,000 businesses to cash a check from a typical unbanked households with full-time workers. Banks and other financial institutions rake in approximately $8bn in fees this way per year (<a href="http://www.brookings.edu/~/media/research/files/reports/2008/1/banking%20fellowes/01_banking_fellowes.pdf">Brookings Institute, 2008</a>).
Doesn’t this call for a technological revolution, a true “disruption”? The economist article cites a few more examples how LIPs are affected:</p>

<ul>
  <li>Overdraft fees - vary between $7 to $40 per transaction (I experienced a painful lesson in this recently, one that cost me $135 on a transactional value of $25 with Bank of America)</li>
  <li>Check-cashing fees - 2-5% of check value</li>
  <li>Cost of remittances to relatives abroad</li>
  <li>ATM withdrawal fees</li>
  <li>Pay-day lenders</li>
  <li>Covering the cost to pay for earned-income tax credits</li>
</ul>

<p>The article claims that these fees can accumulate up to $40,000 over the career of a full-time worker. Assuming that such a career averages 40 years and that the average cost is more like $20,000 over a lifetime, that still equates to approximately $500 per year. Seeing the poverty line is $23,834 for a family of four (<a href="http://www.povertyusa.org/the-state-of-poverty/poverty-facts/">Poverty USA</a>) that is a huge cost. That is not to say that all of these full-time workers would fall under the poverty line, but even at a higher income of say $30,000 a year for an individual, $500 is a hefty amount.</p>

<h2 id="the-under-banked---a-market-opportunity-with-great-potential">The under-banked - a market opportunity with great potential?</h2>

<p>Seeing that around 45m US Americans live below the poverty there is a significant market for providing services for the “under-banked”. At a very modest assumption of $5 in financial services fees per month (any kind) , this equates to a market of roughly $3bn. Seeing that the fees from checking cashes only however rack up to $8bn the market is ultimately much bigger. Many companies in that space such as retail banks and check-cashers are also quite old (Western Union, Moneygram, RiteCheck) and seem ripe to see some innovation.</p>

<p>The US has brought about an abundance of financial technology innovation in the past few years alone. Traditional providers of financial services in spaces such as wealth management (Wealthfront, Betterment, Acorns), savings behavior (Mint, Digit.co), banking (Simple, Coin), payments (Dwolla, Stripe, Apple pay), transfers (Venmo, Square Cash) and consumer loans (Lending club, Affirm) have been thoroughly shook up.</p>

<p>However, almost all of these services are geared towards a technologically savvy population, usually in their 20-40s and college educated. They provide great user-experience but are usually available on smartphones and the Internet (with the exception of Digit.co which works through SMS services).</p>

<p>How can we utilize some of the technologies developed over the past years to provide some of the aforementioned services at a much lower cost? I see several areas that would be interesting to start in:</p>

<ul>
  <li>Text-based banking (not necessarily on a smartphone but more akin to the examples set in developing countries such as Kenya with m-Pesa)</li>
  <li>Prepaid debit cards</li>
  <li>Tools to incentive and enable savings (see digit.co)</li>
  <li>Earned-income tax credit (EITC) loan instruments - this is actually a very interesting space since payouts occur once a year and can be reasonably predicted. Providing loans to finance immediate needs that can then be offset with the single, once-a-year EITC could encourage savings and more reasonable spending behavior.</li>
  <li>mobile-based or neighborhood-based check-cashing services</li>
</ul>

<p>All of these niche markets could lead to the development of an integrated financial services company that specifically chooses LIP as it’s target customers.</p>

<h2 id="the-challenges">The challenges</h2>

<p>The challenges in this space are abundant. As technologists, business and UX experts we would be dealing with a population that does not necessarily has been exposed to technology as much as we have. Even the technological solutions would look entirely different from the high-tech, computing-intensive approaches based on the newest gadgets currently in use. LIPs do not necessarily possess smartphones, so a text-based service might be most sensible here Someone looking to approach this problem would do well looking at examples from developing countries, such as aforementioned m-Pesa in Kenya.</p>

<p>Besides that, many challenges can arise from the unwillingness of investors to provide the necessary capital to get a company off the ground that would like to scale and develop it’s proprietary technological solution. LIPs are not necessary the target group of most startups today. Luckily, alternative financing models are emerging through impact investing and resources such as the <a href="http://www.accion.org/venturelab">Venture Lab</a>.</p>

<p>These are some of the challenges that I see:</p>

<ul>
  <li>Gaining consumer trust - LIPs have more often than not been exploited by companies rather than being served in a responsible manner</li>
  <li>Product adoption</li>
  <li>Product and solution development</li>
  <li>Financing (particularly venture financing which might not be interested in this kind of business but which can provide the kind of expertise and connections necessary to succeed in such an endeavor)</li>
  <li>Identifying the right beach-head market within that specific segment</li>
  <li>Regulation - this might actually be the biggest challenge within the space. Financial services are strictly regulated both by federal government as well internal regulations should you cooperate with a bank</li>
</ul>

<p>The challenges are daunting but the pay-offs could be tremendous as well.</p>

<p>It might be useful to recognize that there is a lot of space to innovate in under-served populations even in industrial countries, not only in the developing world (where we could learn a lot however in trying to solve our own problems). Also, as the authors of <a href="http://www.amazon.com/Poor-Economics-Radical-Rethinking-Poverty/dp/1610390938">Poor Economics</a> point out, LIPs are more than willing to pay for useful services so they should not be neglected in looking to establish successful for-profit technology companies.</p>

<p>I would love to hear your opinion on this matter. Shoot me an <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#106;&#117;&#108;&#105;&#117;&#115;&#100;&#097;&#110;&#101;&#107;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;">email</a> or leave a comment, would be happy to hear what you think the challenges are, what other opportunities lie in that space or what companies are already active.</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/blog//coding/2015/07/14/persistent-pins-tutorial/">
        Swift Tutorial -  Persistent Annotations in MapKit with Core Data
      </a>
    </h1>

    <span class="post-date">14 Jul 2015</span>

    <h2 id="persistent-annotations-in-mapkit">Persistent Annotations in MapKit</h2>

<p>Hi everyone, in this tutorial we will use CoreData to persist pin annotations on a map using Apple’s MapKit in six simple steps. Basic familiarity with CoreData and iOS development is assumed. This tutorial was done for an iPhone 6 and iOS 8.</p>

<p>In Persistent-Pins we will drop pins on a mapView using the UILongPressGestureRecognizer. Dropped Pins will be immediately saved to a CoreData database. Pins can be deleted with taps. On restart, all placed Pins will have persisted on the map. My Github contains the finished project with comments, the steps can be found as commits.</p>

<p>Github link to finished project: <a href="https://github.com/juliusdanek/Persistent-Pins-Tutorial">https://github.com/juliusdanek/Persistent-Pins-Tutorial</a></p>

<h3 id="step-one---setting-up-our-model-and-coredata">Step one - Setting up our model and CoreData</h3>

<p>Let’s start by initializing the project. Create a new project in Xcode, starting from a single view application. Choose Swift as language and enable CoreData by ticking the “Use Core Data” box.</p>

<p><img src="/blog/assets/images/start-model.png" alt="Start model picture" /></p>

<p>Your project is now ready. Checkout how CoreData is initialized in the AppDelegate.</p>

<p>Let’s navigate to our model, “Persistent-Pins”. This is where we are going to define our entity. Let’s add one entity and name it “Pin”. Add two attributes to your new “Pin” entity. “latitude” and “longitude” are both going to be attributes and will be of type “Double”. We will store our Pin’s latitude and longitude in these properties. 
###Step two - Setting up our managed object</p>

<p>Next, we are going to set up our managed object or entity. Navigate to your model “Persistent Pins” and go on “Editor”. Select “create NSManaged Object subclass…”. Choose Persistent Pins, then Pin, then change the language to Swift and save the file to your project folder (select the right group - persistent pins - in the group dropdown).</p>

<p><img src="/blog/assets/images/pin-attribute.png" alt="pin attributes picture" /></p>

<p>At the top of the file, create another import statement for MapKit. We will need CoreData to save our Pins to our model and we will need MapKit to make the Pins that we save a subclass of MKAnnotation - this will allow us to populate our map with Pins directly from CoreData.</p>

<p>Place an @objc(Pin) under your import statements to ensure compatibility with objective-c - see <a href="http://stackoverflow.com/questions/24015185/generating-swift-models-from-core-data-entities">http://stackoverflow.com/questions/24015185/generating-swift-models-from-core-data-entities</a> for more details.</p>

<p>You can see that “Pin” is already a subclass of NSManagedObject. Let’s make it a subclass of MKAnnotation as well. We will now receive an error message that our Pin does not conform to the MKAnnotation protocol. Let’s change that.</p>

<p>At the bottom of the class declaration, add the variable “coordinate” of class CLLocationCoordinate2D like so:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nl">coordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
	        <span class="k">return</span> <span class="n">CLLocationCoordinate2D</span><span class="p">(</span><span class="nl">latitude</span><span class="p">:</span> <span class="n">latitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude</span><span class="p">:</span> <span class="n">longitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">)</span>
	    <span class="p">}</span></code></pre></div>

<p>By now you will have noticed that latitude and longitude are declared as NSNumber. The problem is that CoreData will not recognize the Swift type <strong>Double</strong>. You will simply have to convert between Doubles and NSNumbers.</p>

<p>Let’s provide our custom init method in the next step. Add this code below where you define your @NSManaged vars.</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kr">override</span> <span class="nf">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="bp">NSEntityDescription</span><span class="p">,</span> <span class="n">insertIntoManagedObjectContext</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="k">init</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="n">entity</span> <span class="o">=</span> <span class="bp">NSEntityDescription</span><span class="p">.</span><span class="n">entityForName</span><span class="p">(</span><span class="s">&quot;Pin&quot;</span><span class="p">,</span> <span class="nl">inManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span><span class="o">!</span>
        
        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
        
        <span class="n">latitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLatitude</span><span class="p">)</span>
        
        <span class="n">longitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLongitude</span><span class="p">)</span>
    <span class="p">}</span></code></pre></div>

<p>Our custom init method allows us to find our entity and initialize a Pin CoreData entry with our custom latitude and longitude values. This initializer will also automatically generate your coordinate.</p>

<p><strong>Finally, navigate to your model and change the class in your Pin entity to “Pin”</strong></p>

<p><img src="/blog/assets/images/pin-class.png" alt="pin class picture" /></p>

<p>Great, we are finished creating our custom object and are done with step one. This should be the finished code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">Foundation</span>
	<span class="k">import</span> <span class="n">CoreData</span>
	<span class="k">import</span> <span class="n">MapKit</span>

	<span class="k">class</span> <span class="nl">Pin</span><span class="p">:</span> <span class="bp">NSManagedObject</span><span class="p">,</span> <span class="bp">MKAnnotation</span> <span class="p">{</span>

	    <span class="p">@</span><span class="n">NSManaged</span> <span class="k">var</span> <span class="nl">latitude</span><span class="p">:</span> <span class="bp">NSNumber</span>
	    <span class="p">@</span><span class="n">NSManaged</span> <span class="k">var</span> <span class="nl">longitude</span><span class="p">:</span> <span class="bp">NSNumber</span>
	    
	    <span class="kr">override</span> <span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="bp">NSEntityDescription</span><span class="p">,</span> <span class="n">insertIntoManagedObjectContext</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">?</span><span class="p">)</span> <span class="p">{</span>
	        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
	    <span class="p">}</span>
	    
	    <span class="k">init</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="p">)</span> <span class="p">{</span>
	        <span class="k">let</span> <span class="n">entity</span> <span class="o">=</span> <span class="bp">NSEntityDescription</span><span class="p">.</span><span class="n">entityForName</span><span class="p">(</span><span class="s">&quot;Pin&quot;</span><span class="p">,</span> <span class="nl">inManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span><span class="o">!</span>
	        <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">(</span><span class="nl">entity</span><span class="p">:</span> <span class="n">entity</span><span class="p">,</span> <span class="nl">insertIntoManagedObjectContext</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
	        <span class="n">latitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLatitude</span><span class="p">)</span>
	        <span class="n">longitude</span> <span class="o">=</span> <span class="bp">NSNumber</span><span class="p">(</span><span class="kt">double</span><span class="o">:</span> <span class="n">annotationLongitude</span><span class="p">)</span>
	    <span class="p">}</span>
	    
	    <span class="k">var</span> <span class="nl">coordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="p">{</span>
	        <span class="k">return</span> <span class="n">CLLocationCoordinate2D</span><span class="p">(</span><span class="nl">latitude</span><span class="p">:</span> <span class="n">latitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">,</span> <span class="nl">longitude</span><span class="p">:</span> <span class="n">longitude</span> <span class="kt">as</span> <span class="n">Double</span><span class="p">)</span>
	    <span class="p">}</span>

	<span class="p">}</span></code></pre></div>

<h3 id="step-three----setting-up-our-ui-and-our-viewcontroller">Step three – setting up our UI and our ViewController</h3>

<p>Navigate to storyboard and drag a MapKit View onto your viewcontroller. Set the constraints so the MapView fills out the entire controller. Also, do not forget to enable MapKit in your projects capabilities. Go to persistent Pins and enable “Maps” under capabilities.</p>

<p><img src="/blog/assets/images/turnon-mapkit.png" alt="mapkit picture" /></p>

<p>Let’s create an outlet for our mapView in our ViewController file. ctrl + drag your mapView into your ViewController using the assistant editor and add an outlet named “mapView”. Do not forget to import MapKit into your ViewController and set your ViewController as MKMapViewDelegate.</p>

<p>In our viewDidLoad method, let’s add a long pressure gesture recognizer that will allow us to drop pins.</p>

<p>Your ViewController should look like this now:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">UIKit</span>
	<span class="k">import</span> <span class="n">MapKit</span>

	<span class="k">class</span> <span class="nl">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">MKMapViewDelegate</span> <span class="p">{</span>

	    <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span>
	    
	    <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
	        <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
	        
	        <span class="k">var</span> <span class="n">longPress</span> <span class="o">=</span> <span class="bp">UILongPressGestureRecognizer</span><span class="p">(</span><span class="nl">target</span><span class="p">:</span> <span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;dropPin:&quot;</span><span class="p">)</span>
	        <span class="n">longPress</span><span class="p">.</span><span class="n">minimumPressDuration</span> <span class="o">=</span> <span class="mf">0.5</span>
	        <span class="n">mapView</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">longPress</span><span class="p">)</span>
	        
	        <span class="n">mapView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
	        
	    <span class="p">}</span>
	<span class="p">}</span></code></pre></div>

<p>As you can see, the UILongPressGestureRecognizer us linked to a method called dropPin. We will implement that method next.</p>

<h3 id="step-four---the-droppin-method">Step four - the dropPin method</h3>

<p>Let’s define our dropPin method. We will have to do three things:</p>

<ol>
  <li>Extract the coordinates from the point where the user touched</li>
  <li>Add an annotation when the UIGestureRecognizerState fires</li>
  <li>Save that annotation to CoreData</li>
</ol>

<p>Let’s start by defining the function and extracting location data:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
	        
	        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
	        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
	    <span class="p">}</span></code></pre></div>

<p>Now, this method does not really do much yet. Let’s add a pin!</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">UIGestureRecognizerState</span><span class="p">.</span><span class="n">Began</span> <span class="o">==</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="bp">MKPointAnnotation</span><span class="p">()</span>
            <span class="n">pin</span><span class="p">.</span><span class="n">coordinate</span> <span class="o">=</span> <span class="n">touchMapCoordinate</span>
            <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>           
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>

<p>Now we can see pins dropping where we touched. This implementation is fairly straightforward. Our pins are not persistent yet though! Let’s change our dropPin function with this code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">UIGestureRecognizerState</span><span class="p">.</span><span class="n">Began</span> <span class="o">==</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">appDelegate</span> <span class="o">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">delegate</span> <span class="kt">as</span><span class="o">!</span> <span class="n">AppDelegate</span>
            
            <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">longitude</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="o">!</span><span class="p">)</span>
            <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
            <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></div>

<p>We will instantiate the appDelegate so we can use its methods. Then we proceed to instantiate a pin as our Pin class. We will initialize it with the coordinates from our touchMapCoordinate and use the appDelegate context as our context. Then we add the pin to our map view and we save our context - we could do this at another point too but it seems smart to do it here. We just successfully added a Pin to our CoreData model!</p>

<h3 id="step-five---fetching-our-pins-and-adding-them-to-our-map-when-starting-our-app">Step five - fetching our Pins and adding them to our map when starting our app</h3>

<p>Alright, let’s make sure that the pins that we insert into CoreData also get fetched when we need them, i.e. when the mapView loads. Let’s first change some of the logic that we implemented before. Import CoreData to our ViewController. Let’s also declare two implicitly unwrapped variables in ViewController:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">var</span> <span class="nl">appDelegate</span><span class="p">:</span> <span class="n">AppDelegate</span><span class="o">!</span>
    <span class="k">var</span> <span class="nl">sharedContext</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">!</span></code></pre></div>

<p>Next, in our viewDidLoad method, at the very top, initialize the two new variables as so:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">appDelegate</span> <span class="o">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">delegate</span> <span class="kt">as</span><span class="o">!</span> <span class="n">AppDelegate</span>
        <span class="n">sharedContext</span> <span class="o">=</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span></code></pre></div>

<p>this allows us to access our NSManagedObjectContext and our saveContext() method throughout the ViewController. 
Do not forget to adjust the dropPin method accordingly! Delete the declaration of appDelegate that we had before and use the sharedContext variable in our init method.</p>

<p>Alright, let’s create a method for a fetchrequest! Simply use this code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="n">fetchAllPins</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nl">error</span><span class="p">:</span> <span class="n">NSErrorPointer</span> <span class="o">=</span> <span class="nb">nil</span>
        <span class="k">let</span> <span class="n">fetchRequest</span> <span class="o">=</span> <span class="bp">NSFetchRequest</span><span class="p">(</span><span class="nl">entityName</span><span class="p">:</span> <span class="s">&quot;Pin&quot;</span><span class="p">)</span>
        <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="n">sharedContext</span><span class="p">.</span><span class="n">executeFetchRequest</span><span class="p">(</span><span class="n">fetchRequest</span><span class="p">,</span> <span class="nl">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Error in fectchAllActors(): \(error)&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span> <span class="kt">as</span><span class="o">!</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span>
    <span class="p">}</span></code></pre></div>

<p>We create a fetchrequest, then execute it. In case there are any errors, we print the error to the console. The results are then returned as an array of pins. Now that we have a method can allows us to access our Pins as an array, let’s put them on the map! At the bottom of our viewDidLoad method, add the following code:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotations</span><span class="p">(</span><span class="n">fetchAllPins</span><span class="p">())</span></code></pre></div>

<p>Great, now we are able to see the pins that we add. Let’s try it out.</p>

<h3 id="step-six---deleting-pins">Step six - deleting pins</h3>

<p>This step is remarkably easy. We will implement one of our delegate methods - didSelectAnnotation. The wonderful thing is that all mapView.annotations are saved as an array - an array of Pins! That means the selected annotation can always be casted as a Pin and deleted from the managed context. The method should look like this:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">func</span> <span class="nf">mapView</span><span class="p">(</span><span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span><span class="p">,</span> <span class="n">didSelectAnnotationView</span> <span class="nl">view</span><span class="p">:</span> <span class="bp">MKAnnotationView</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">annotation</span> <span class="kt">as</span><span class="o">!</span> <span class="n">Pin</span>
        <span class="n">sharedContext</span><span class="p">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">mapView</span><span class="p">.</span><span class="n">removeAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
    <span class="p">}</span></code></pre></div>

<p>That was our last method! Our viewController should now look like this:</p>

<div class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">import</span> <span class="n">CoreData</span>
<span class="k">import</span> <span class="n">UIKit</span>
<span class="k">import</span> <span class="n">MapKit</span>

<span class="k">class</span> <span class="nl">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">MKMapViewDelegate</span> <span class="p">{</span>

    <span class="p">@</span><span class="kt">IBOutlet</span> <span class="k">weak</span> <span class="k">var</span> <span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span>
    
    <span class="k">var</span> <span class="nl">appDelegate</span><span class="p">:</span> <span class="n">AppDelegate</span><span class="o">!</span>
    <span class="k">var</span> <span class="nl">sharedContext</span><span class="p">:</span> <span class="bp">NSManagedObjectContext</span><span class="o">!</span>
    
    <span class="kr">override</span> <span class="k">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
        
        <span class="n">appDelegate</span> <span class="o">=</span> <span class="bp">UIApplication</span><span class="p">.</span><span class="n">sharedApplication</span><span class="p">().</span><span class="n">delegate</span> <span class="kt">as</span><span class="o">!</span> <span class="n">AppDelegate</span>
        
        <span class="n">sharedContext</span> <span class="o">=</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span>
        
        <span class="k">var</span> <span class="n">longPress</span> <span class="o">=</span> <span class="bp">UILongPressGestureRecognizer</span><span class="p">(</span><span class="nl">target</span><span class="p">:</span> <span class="nb">self</span><span class="p">,</span> <span class="nl">action</span><span class="p">:</span> <span class="s">&quot;dropPin:&quot;</span><span class="p">)</span>
        <span class="n">longPress</span><span class="p">.</span><span class="n">minimumPressDuration</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">mapView</span><span class="p">.</span><span class="n">addGestureRecognizer</span><span class="p">(</span><span class="n">longPress</span><span class="p">)</span>
        
        <span class="n">mapView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span>
        
        <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotations</span><span class="p">(</span><span class="n">fetchAllPins</span><span class="p">())</span>
    <span class="p">}</span>
    
    <span class="k">func</span> <span class="n">dropPin</span><span class="p">(</span><span class="nl">gestureRecognizer</span><span class="p">:</span> <span class="bp">UIGestureRecognizer</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">tapPoint</span><span class="p">:</span> <span class="bp">CGPoint</span> <span class="o">=</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">locationInView</span><span class="p">(</span><span class="n">mapView</span><span class="p">)</span>
        <span class="k">let</span> <span class="nl">touchMapCoordinate</span><span class="p">:</span> <span class="n">CLLocationCoordinate2D</span> <span class="o">=</span> <span class="n">mapView</span><span class="p">.</span><span class="n">convertPoint</span><span class="p">(</span><span class="n">tapPoint</span><span class="p">,</span> <span class="nl">toCoordinateFromView</span><span class="p">:</span> <span class="n">mapView</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">UIGestureRecognizerState</span><span class="p">.</span><span class="n">Began</span> <span class="o">==</span> <span class="n">gestureRecognizer</span><span class="p">.</span><span class="n">state</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="nl">annotationLatitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">latitude</span><span class="p">,</span> <span class="nl">annotationLongitude</span><span class="p">:</span> <span class="n">touchMapCoordinate</span><span class="p">.</span><span class="n">longitude</span><span class="p">,</span> <span class="nl">context</span><span class="p">:</span> <span class="n">appDelegate</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="o">!</span><span class="p">)</span>
            <span class="n">mapView</span><span class="p">.</span><span class="n">addAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
            <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">func</span> <span class="n">mapView</span><span class="p">(</span><span class="nl">mapView</span><span class="p">:</span> <span class="bp">MKMapView</span><span class="o">!</span><span class="p">,</span> <span class="n">didSelectAnnotationView</span> <span class="nl">view</span><span class="p">:</span> <span class="bp">MKAnnotationView</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">annotation</span> <span class="kt">as</span><span class="o">!</span> <span class="n">Pin</span>
        <span class="n">sharedContext</span><span class="p">.</span><span class="n">deleteObject</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">mapView</span><span class="p">.</span><span class="n">removeAnnotation</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
        <span class="n">appDelegate</span><span class="p">.</span><span class="n">saveContext</span><span class="p">()</span>
    <span class="p">}</span>
    
    
    <span class="k">func</span> <span class="n">fetchAllPins</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span> <span class="p">{</span>
        
        <span class="k">let</span> <span class="nl">error</span><span class="p">:</span> <span class="n">NSErrorPointer</span> <span class="o">=</span> <span class="nb">nil</span>
        <span class="k">let</span> <span class="n">fetchRequest</span> <span class="o">=</span> <span class="bp">NSFetchRequest</span><span class="p">(</span><span class="nl">entityName</span><span class="p">:</span> <span class="s">&quot;Pin&quot;</span><span class="p">)</span>
        <span class="k">let</span> <span class="n">results</span> <span class="o">=</span> <span class="n">sharedContext</span><span class="p">.</span><span class="n">executeFetchRequest</span><span class="p">(</span><span class="n">fetchRequest</span><span class="p">,</span> <span class="nl">error</span><span class="p">:</span> <span class="n">error</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span> <span class="o">!=</span> <span class="nb">nil</span> <span class="p">{</span>
            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Error in fectchAllActors(): \(error)&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">results</span> <span class="kt">as</span><span class="o">!</span> <span class="p">[</span><span class="n">Pin</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Tada! We are finished. Additional modification could include: Adding data like photos to a Pin, and defining a relationship between a Photo and the Pin object, using NSFetchResultsController to get results and update UI, modifying appearance of the Pins, displaying user location on map, etc.</p>

<p>I hope you enjoyed this tutorial!</p>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/blog/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
